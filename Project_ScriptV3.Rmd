Logistic growth in discrete time

n[t+1] = Population size in next generation = (1 + r (1 - n[t]/K)) n[t]

Recursion equation:

n = n[t+1] - n[t] = r (1 - n[t]/K) n[t]

```{r}
require(tidyverse)
```

```{r step growth function}
# calculates n[t+1] from state n[t] and parameters
# RETURNS NEXT TIME STEP POPULATION SIZE NOT HOW MUCH GROWTH
step_growth <- function(state, params){
  with(as.list(c(state,params)),{
  nt <- state[["n"]]
  r <- params[["r"]]
  K <- params[["K"]]
  
  next_state <- (1 + r*(1-nt/K))*nt
  return(round(as.numeric(next_state)))
  })
}
```

```{r num of migrants function}
migrants_number <- function(n){
  return(rbinom(n = 1, size = n, prob = 0.5))
}
```

```{r direction randomizer}
direction_generator <-function(){
  return(sample(c(-1, 1), 1))
}
```

```{r}
# test parameters and state
params <- c(r = 1, K = 1000, N0 = 10)
times <- seq(0,100,1)
ns <- list("t"=times);ns$n[1]<-params[["N0"]]
ns <- list("n"=params[["N0"]])
initial_state <- c(t=ns$t[1], n=ns$n[1])

# testing the function
step_growth(initial_state, params)
```

```{r test initial world}
world <- list("1" = list("n1" = 10, "n2" = 10), 
              "2" = list("n1" = 0, "n2" = 0), 
              "3" =  list("n1" = 0, "n2" = 0),
              "4" = list("n1" = 0, "n2" = 0), 
              "5" = list("n1" = 0, "n2" = 0), 
              "6" = list("n1" = 0, "n2" = 0), 
              "7" = list("n1" = 0, "n2" = 0), 
              "8" = list("n1" = 0, "n2" = 0), 
              "9" = list("n1" = 0, "n2" = 0), 
              "10" = list("n1" = 0, "n2" = 0)
              )
```

```{r}
world <- list(p1 = list(n1 = 10, n2 = 10),
              p2 = list(n1 = 5, n2 = 5),
              p3 = list(n1 = 1, n2 = 0),
              p4 = list(n1 = 10, n2 = 0))
```


```{r world step growth function}
world_step_growth <- function(world, params, steps){
  for(t in 1:length(steps)){
    now_world <- world
    patches <- c(names(world))
    
    n1_params <- c(r = params[["n1_r"]], K = params[["n1_K"]])
    n2_params <- c(r = params[["n2_r"]], K = params[["n2_K"]])
    
    next_world <- map_depth(world, 2, \(x) x=0)
    
    for (i in 1:length(patches)){
      now_patch <- world[[i]]
      
      now_n1_state <- c(n=now_patch[[1]][[1]])
      now_n2_state <- c(n=now_patch[[2]][[1]])
        
      next_n1_state <- step_growth(now_n1_state,n1_params)
      next_n2_state <- step_growth(now_n2_state,n2_params)
  
      next_world <- assign_in(next_world, list(i, "n1"), next_n1_state)
      next_world <- assign_in(next_world, list(i, "n2"), next_n2_state)
    }
    world <- next_world
  }
  return(world)
}
```

```{r}
migration_step <- function(world, steps){
  for (t in 1:length(steps)){
    
    # know number of migrants per patch
    migrants <- map_depth(world, 2, migrants_number)
    
    # know direction of migrants per patch
    directions <- map_depth(world, 2, \(x) direction_generator())
    
    # know migrant origin patch
    migrant_origins <- map_depth(world, 2, \(x) x=0)
    
    for (i in 1:length(patches)){
      migrant_origins[[i]][[1]] <- i
      migrant_origins[[i]][[2]] <- i
    }
    
    # know migrant destination patch
    migrant_destinations <- migrant_origins
    
    for (i in 1:length(patches)){
      migrant_destinations[[i]][[1]] <- migrant_origins[[i]][[1]] + directions[[i]][[1]]
      migrant_destinations[[i]][[2]] <- migrant_origins[[i]][[2]] + directions[[i]][[2]]
    }
    
    # validate destination of migrants
    validated_dest <- migrant_destinations
    
    for (i in 1:length(patches)){
      if (validated_dest[[i]][[1]] == 0 | validated_dest[[i]][[1]] > length(patches)){
        validated_dest[[i]][[1]] <- migrant_origins[[i]][[1]]
      }
      if (validated_dest[[i]][[2]] == 0 | validated_dest[[i]][[2]] > length(patches)){
        validated_dest[[i]][[2]] <- migrant_origins[[i]][[2]]
      }
    }
    
    # add migrants from population of destination patch
    next_world <- world
    
    for (i in 1:length(patches)){
      n1_dest <- validated_dest[[i]][[1]]
      next_world[[n1_dest]][[1]] <- next_world[[n1_dest]][[1]] + migrants[[n1_dest]][[1]]
      
      n2_dest <- validated_dest[[i]][[2]]
      next_world[[n2_dest]][[2]] <- next_world[[n2_dest]][[2]] + migrants[[n2_dest]][[2]]
    }
    
    # subtract migrants to population of origin patch
    now_world <- world
    
    for (i in 1:length(patches)){
      next_world[[i]][[1]] <- next_world[[i]][[1]] - migrants[[i]][[1]]
      next_world[[i]][[2]] <- next_world[[i]][[2]] - migrants[[i]][[2]]
    }
    world <- next_world
  }
  return(world)
}
```

```{r simulation function}
simulation <- function(world, params, times, steps = seq(0,1,1)){
  next_world <- world
  for (t in 1:length(times)){
      next_world <- world_step_growth(next_world, params, steps)
      migration_step(next_world, steps)
  }
  return(next_world)
}
```


```{r testing world step function}
world <- list(p1 = list(n1 = 10, n2 = 10),
              p2 = list(n1 = 5, n2 = 5),
              p3 = list(n1 = 1, n2 = 0),
              p4 = list(n1 = 10, n2 = 0))

params <- c(n1_r = 1,
            n2_r = 1,
            n1_K = 1000,
            n2_K = 1000
            )

steps <- seq(0,1,1)

world_step_growth(world, params, steps)  
```

```{r testing migration step function}
migration_step(world,steps)
```

```{r testing simulation function}
world <- list(p1 = list(n1 = 10, n2 = 10),
              p2 = list(n1 = 5, n2 = 5),
              p3 = list(n1 = 1, n2 = 0),
              p4 = list(n1 = 10, n2 = 0))

params <- c(n1_r = 0.1,
            n2_r = 0.01,
            n1_K = 1000,
            n2_K = 1000
            )

times <- seq(0,100,1)

simulation(world, params, times)
```



