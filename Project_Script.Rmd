

Just loading any necessary libraries

```{r}
library(tidyverse)

```

For proof-of-concept we are currently manually creating one specific world and set of parameters to demonstrate how the functions will run on this example
```{r world and parameters}
# my_world <- list("1" = list("n1" = 10, "n2" = 10), 
#               "2" = list("n1" = 0, "n2" = 0), 
#               "3" = list("n1" = 0, "n2" = 0),
#               "4" = list("n1" = 0, "n2" = 0), 
#               "5" = list("n1" = 0, "n2" = 0), 
#               "6" = list("n1" = 0, "n2" = 0), 
#               "7" = list("n1" = 0, "n2" = 0), 
#               "8" = list("n1" = 0, "n2" = 0), 
#               "9" = list("n1" = 0, "n2" = 0), 
#               "10" = list("n1" = 0, "n2" = 0))
# my_params <- list("n1" = list("r" = 0.1, "k" = 1000), 
#                "n2" = list("r" = 0.1, "k" = 1000))
```
Now that the world is created, we have made a set of functions and algorithms to run our simulation.


The following will determine how many individuals will migrate from a patch based on a binomial draw
```{r migrant num function}
migrants_number <- function(n){
  return(rbinom(n = 1, size = n, prob = 0.5))
}
```

The following will randomly determine which direction a population will migrate to.
```{r direction generator}
direction_generator <-function(){
  return(sample(c(-1, 1), 1))
}
direction_generator()

```

The following is the population growth, that calculates by how much a given population will grow based on the logistic growth equation 
```{r growth function}
growth <- function(r, k, n){
  return((1 + r*(1-n/k))*n)
}
growth(r = 10, k = 100, n = 10)
```

The following chunk simulates the the growth and migration for 10 timesteps, note that there are a lot of things that we have hard coded a lot of the steps here instead of creating functions for everything so that we have a proof of concept that works. It first applies the logistic growth rate on all the populations in all the patches, then applies the movement function on each population in each patch after they have grown for 1 timestep, as this meets our assumptions more accurately.
the plan is to have each of these steps converted to their unique functions of growth and movement across any world of any size. Then they will be combined to one "simulate" function so that eventually we can include the checker that will stop the simulation when one of the populations wins. 

please ignore the comments which were used for troubleshooting

also note that currently the _ceiling()_ function is being called on the n parameter when determining the number of migrants, as not doing so causes rbinom to take a float, that was generated as a result of us using the logistic growth function, and rbinom cannot work on floats, it requires whole numbers/integers
```{r simulate function}
simulate <- function(world, params){
  # running for a max of 1000 time steps
  # should stop before 1000 when a population wins
  i <- 0
  while(i<1000){
    
    # growth on all patches
    for(patch in seq(1, length(world))){
      
      # growth within each patch
      for(pop in seq(1, length(world[[patch]]))){
        curr_pop_name <- names(world[[patch]][pop])
        curr_pop <- world[[patch]][[curr_pop_name]]
        world[[patch]][[curr_pop_name]] <- round(growth(r = params[[curr_pop_name]][["r"]], k = params[[curr_pop_name]][["k"]], n = curr_pop)) -> curr_pop
      }
    }
    
    # movement on all patches
    for(patch in seq(1, length(world))){
      
      # movement of each patch
      for(pop in seq(1, length(world[[patch]]))){
        curr_pop_name <- names(world[[patch]][pop])
        curr_pop <- world[[patch]][[curr_pop_name]]
        migrants <- migrants_number(floor(curr_pop))
        direction <- direction_generator()
        destination <- patch + direction
        if(all(destination > 0 & destination <= length(world))){
          world[[patch]][[curr_pop_name]] <- world[[patch]][[curr_pop_name]] - migrants
          world[[destination]][[curr_pop_name]] <- world[[destination]][[curr_pop_name]] + migrants
      }
     }
    }
    
    # checking if one of them won
    if(sum(unlist(world[[length(world)]])) > 0){
      result <- list(world)
      last_patch <- unlist(world[[length(world)]])
      
      # checking who won
      winner <- case_when(
        last_patch[[1]] > 0 & last_patch[[2]] > 0 ~ NA,
        last_patch[[1]] == 0 & last_patch[[2]] > 0 ~ "n2",
        last_patch[[2]] == 0 & last_patch[[1]] > 0 ~ "n1"
          )
      
      r1 <- params[["n1"]][["r"]]
      r2 <- params[["n2"]][["r"]]
      k1 <- params[["n1"]][["k"]]
      k2 <- params[["n2"]][["k"]]
      
      # put the results in a new row in simulation_data  
      simulation_data %>% add_row(worlds = result, timestep = i, parameters = list(params), winner = winner, r1 = r1, r2 = r2, k1 = k1, k2 = k2) -> simulation_data
      return(simulation_data)
    }
    i <- i + 1
  }
}

```

```{r testing simulation function}
# #making the dataframe empty
# simulation_data <- tibble(worlds = list(), timestep = numeric(), parameters = list(), winner = character(), winner_r = numeric(), winner_k = numeric(), loser_r = numeric(), loser_k = numeric())
# 
# #running our simulation for howevermany replications we want
# for(i in seq(1, 1000, 1)){
# simulation_data <- simulate(my_world, my_params)
# }

```



From here, we plan on tracking the winners, and seeing frequently each population wins as their parameters(r and k) change, and plot our results

```{r dummy world and parameters}
# dummy_world <- list("1" = list("n1" = 10, "n2" = 10), 
#                     "2" = list("n1" = 0, "n2" = 0), 
#                     "3" = list("n1" = 0, "n2" = 0),
#                     "4" = list("n1" = 0, "n2" = 0), 
#                     "5" = list("n1" = 0, "n2" = 0), 
#                     "6" = list("n1" = 0, "n2" = 0), 
#                     "7" = list("n1" = 0, "n2" = 0), 
#                     "8" = list("n1" = 0, "n2" = 0), 
#                     "9" = list("n1" = 0, "n2" = 0), 
#                     "10" = list("n1" = 0, "n2" = 0))

# make world with a number of patches
dummy_world <- vector(mode="list",length=20)
names(dummy_world) <- as.character(1:length(dummy_world))
dummy_world[[1]] <- list("n1" = 10, "n2" = 10)

for (i in 2:length(dummy_world)){
  dummy_world[[i]] <- list("n1" = 0, "n2" = 0)
  i<-i+1
}

dummy_params1 <- list("n1" = list("r" = 0.1, "k" = 1000), 
                      "n2" = list("r" = 0.1, "k" = 1000))

dummy_params2 <- list("n1" = list("r" = 0.05, "k" = 1000), 
                      "n2" = list("r" = 0.1, "k" = 1000))

dummy_params3 <- list("n1" = list("r" = 0.1, "k" = 500), 
                      "n2" = list("r" = 0.1, "k" = 1000))
```

```{r dummy simulations}
# SIM 1
#making the dataframe empty
simulation_data <- tibble(worlds = list(), timestep = numeric(), parameters = list(), winner = character(), r1 = numeric(), r2 = numeric(), k1 = numeric(), k2 = numeric()) -> sim_data_reset

#running our simulation for howevermany replications we want
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(dummy_world, dummy_params1)
}

dummy_sim1 <- cbind(simulation_data, simulation = 1)

# SIM 2
#making the dataframe empty
simulation_data <- sim_data_reset

#running our simulation for howevermany replications we want
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(dummy_world, dummy_params2)
}

dummy_sim2 <- cbind(simulation_data, simulation = 2)

# SIM 3
#making the dataframe empty
simulation_data <- sim_data_reset

#running our simulation for howevermany replications we want
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(dummy_world, dummy_params3)
}

dummy_sim3 <- cbind(simulation_data, simulation = 3)


dummy_all <- rbind(dummy_sim1,dummy_sim2,dummy_sim3)
```

```{r dummy plots}
dummy_all %>%
  filter(!is.na(winner)) %>% 
  group_by(winner, r1, k1, r2, k2) %>% 
  ggplot(aes(x = timestep))+
  facet_wrap(~r1+r2+k1+k2)+
  geom_histogram(aes(x = timestep, fill = winner), binwidth = 1)
```

```{r world and params to test}
# --WORLD--
# make world with a number of patches
world <- vector(mode="list",length=20)
names(world) <- as.character(1:length(world))
world[[1]] <- list("n1" = 10, "n2" = 10)

for (i in 2:length(world)){
  world[[i]] <- list("n1" = 0, "n2" = 0)
  i<-i+1
}

# --PARAMETERS--
# summary:
# control
# r1 halved
# k1 halved
# r1 doubled
# k1 doubled
# r1 halved, k1 halved      <-- not sure if we need 
# r1 doubled, k1 doubled    <-- both of these or if one is enough
# r1 halved, r2 doubled
# k1 halved, k2 doubled

# control
params0 <- list("n1" = list("r" = 0.1, "k" = 1000), 
                "n2" = list("r" = 0.1, "k" = 1000))
# r1 halved
params1 <- list("n1" = list("r" = 0.05, "k" = 1000), 
                "n2" = list("r" = 0.1, "k" = 1000))
# k1 halved
params2 <- list("n1" = list("r" = 0.1, "k" = 500), 
                "n2" = list("r" = 0.1, "k" = 1000))
# r1 doubled
params3 <- list("n1" = list("r" = 0.2, "k" = 1000), 
                "n2" = list("r" = 0.1, "k" = 1000))
# k1 doubled
params4 <- list("n1" = list("r" = 0.1, "k" = 2000), 
                "n2" = list("r" = 0.1, "k" = 1000))
# r1 halved, k1 halved
params5 <- list("n1" = list("r" = 0.05, "k" = 500), 
                "n2" = list("r" = 0.1, "k" = 1000))
# r1 doubled, k1 doubled
params6 <- list("n1" = list("r" = 0.2, "k" = 2000), 
                "n2" = list("r" = 0.1, "k" = 1000))
# r1 halved, r2 doubled
params7 <- list("n1" = list("r" = 0.05, "k" = 1000), 
                "n2" = list("r" = 0.2, "k" = 1000))
# k1 halved, k2 doubled
params8 <- list("n1" = list("r" = 0.1, "k" = 500), 
                "n2" = list("r" = 0.1, "k" = 2000))
```


```{r simulations}
#making the empty dataframe
simulation_data <- tibble(worlds = list(), timestep = numeric(), parameters = list(), winner = character(), r1 = numeric(), r2 = numeric(), k1 = numeric(), k2 = numeric()) -> sim_data_reset

# SIM 1
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params1)
}

sim1 <- cbind(simulation_data, simulation = 1)

# SIM 2
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params2)
}

sim2 <- cbind(simulation_data, simulation = 2)

# SIM 3
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params3)
}

sim3 <- cbind(simulation_data, simulation = 3)

# SIM 4
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params4)
}

sim4 <- cbind(simulation_data, simulation = 4)

# SIM 5
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params5)
}

sim5 <- cbind(simulation_data, simulation = 5)

# SIM 6
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params6)
}

sim6 <- cbind(simulation_data, simulation = 6)

# SIM 7
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params7)
}

sim7 <- cbind(simulation_data, simulation = 7)

# SIM 8
simulation_data <- sim_data_reset
for(i in seq(1, 1000, 1)){
simulation_data <- simulate(world, params8)
}

sim8 <- cbind(simulation_data, simulation = 8)

all_sims <- rbind(sim1,sim2,sim3,sim4,sim5,sim6,sim7,sim8)
```

```{r plot}
all_sims %>%
  filter(!is.na(winner)) %>% 
  group_by(winner, r1, k1, r2, k2) %>% 
  ggplot(aes(x = timestep))+
  facet_wrap(~r1+r2+k1+k2,labeller = labeller(.multi_line=FALSE, .default=label_both))+
  geom_histogram(aes(x = timestep, fill = winner), binwidth = 1)
```

