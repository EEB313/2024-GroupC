---
title: "EEB313 Project"
author: "Claire Abbasi"
date: "2024-11-14"
output: pdf_document
---
```{r, warning=FALSE}
library(dplyr)
library(tidyverse)
```

# Setting the dimensions for the grid using seq. Expand.grid used in order to make a data 
frame containing all x and y coordination combinations, initial population for each grid was set to0. Uniting the x and y columns to create a coordinate column while keeping x and y columns. Adding constant b, d, e, and i for now.

```{r}
grid_dimineions  <- seq(0,5)

expand.grid(x = grid_dimineions, y = grid_dimineions) -> grid

grid %>% unite(coordinates, c(x,y), sep = ',', remove = FALSE) %>% 
  mutate(d = 0.4, b = 0.8, e = 0.2, i = 0.1, n = 10 )-> grid

```


#Defining a funcation for the base equation 'equation_func'
```{r}
eqation_func <- function(n, b, d, i, e){
  return(n+b*n - d*n + i*n - e*n)
}

```


#Take all emmigrants from each patch and putting into a seperate coloumn using a for loop
#this same loop will be used to redistribute the emigrants only to the nearest coordinate
#to the left for now into new populations and remove new emigrant column in grid data frame.
```{r}
##Next objecting getting the loop to work as the emigration_immigration function to 
#put into the larger simulator. 

#emigration_immigration <- function(grid){
nearest_left_x <- NULL
same_y <- NULL

for(i in 1:nrow(grid)){
  grid$emigrants[i] <- grid$n[i] #* grid$e[i]
  
  grid$n[i] = grid$n[i] - grid$emigrants[i]
  
    nearest_left_x <- grid$x[i] - 1
   nearest_left_y <- grid$y[i]
  

 left_found <- FALSE
  for (j in 1:nrow(grid)) {
    if (grid$x[j] == nearest_left_x && grid$y[j] == nearest_left_y) {
      grid$n[j] <- grid$n[j] + grid$emigrants[i]
      left_found <- TRUE
    }
  }
  if (!left_found) {
    grid$n[i] <- grid$n[i] + grid$emigrants[i]
  }
  
  grid$emigrants[i] <- 0  

}

```



The following is our simulator a function we made to apply the base equation to every
patch to simulate one timestep.
```{r}
simulator <- function(data){
  next_ns <- NULL
  for(i in 1:nrow(data)){
    next_ns[i] = eqation_func(data$n[i], data$b[i], data$d[i], data$i[i], data$e[i])
  }
  result <- data.frame(data |> mutate(n = next_ns))
  return(result)
}

```

#Example of potential visualization method
```{r}
simulator(data = grid) %>% ggplot(aes(x = x, y = y, fill = n)) +
  geom_tile(colour = "black")


grid %>% ggplot(aes(x = x, y = y, fill = n)) +
  geom_tile(colour = "black")
```


#Buildign an euclidean distance calculator
```{r}
euclidean_distance <- function(x1, x2, y1, y2){
  return(sqrt(((x2 - x1)^2 + (y2 - y1)^2)))
}
euclidean_distance(0, 0, 1, 0)
```
 




